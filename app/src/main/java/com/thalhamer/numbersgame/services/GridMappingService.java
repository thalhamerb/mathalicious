package com.thalhamer.numbersgame.services;import android.animation.Animator;import android.animation.AnimatorListenerAdapter;import android.animation.ValueAnimator;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.os.Handler;import android.util.Log;import android.view.animation.AccelerateInterpolator;import android.view.animation.LinearInterpolator;import com.thalhamer.numbersgame.Factory.App;import com.thalhamer.numbersgame.R;import com.thalhamer.numbersgame.domain.FloatingPointsDisplay;import com.thalhamer.numbersgame.domain.GameDataHolder;import com.thalhamer.numbersgame.domain.GridData;import com.thalhamer.numbersgame.domain.GridMapping;import com.thalhamer.numbersgame.domain.Image;import com.thalhamer.numbersgame.domain.LevelInfo;import com.thalhamer.numbersgame.domain.Tile;import com.thalhamer.numbersgame.enums.GameState;import com.thalhamer.numbersgame.enums.GameType;import com.thalhamer.numbersgame.enums.ScoreType;import com.thalhamer.numbersgame.enums.sounds.SoundEnum;import com.thalhamer.numbersgame.viewhelper.GameConstants;import com.thalhamer.numbersgame.viewhelper.GameStateHolder;import com.thalhamer.numbersgame.viewhelper.TouchStateHolder;import java.util.ArrayList;import java.util.List;import javax.inject.Inject;import javax.inject.Singleton;/** * performs grid mapping services * <p/> * Created by Brian on 1/25/2015. */@Singletonpublic class GridMappingService {    public static final float GRID_VERTICAL_PERCENTAGE = 0.65f;//    public static final int BOUNCE_TIME = 100;    @Inject    GridService gridService;    @Inject    StatsService statsService;    @Inject    GameDataHolder gameDataHolder;    @Inject    LevelEndService levelEndService;    @Inject    SoundService soundService;    //    private float previousDropFactor = 0;    private int numOfBlockDropsCompleted = 0;    private int numOfBlocksToDrop = 0;    private Paint gridBorderPaint;    private Paint gridLinesWidth;    private Float gridWidth;    private Float gridHeight;    public void setInitialBoard() {        initGridDimensions();        initializeGridLines();        initializeTilesAndImages();    }    private void initGridDimensions() {        float theGridHeight = App.getDisplayHeight() * GRID_VERTICAL_PERCENTAGE;        gridHeight = theGridHeight;        gridWidth = theGridHeight < App.getDisplayWidth() ? theGridHeight : (float) App.getDisplayWidth();    }    private void initializeTilesAndImages() {        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        Float tileWidth = getRectangleWidth(gridData);        Float tileHeight = getRectangleHeight(gridData);        float currYPixel = getTopOfGrid() + gridHeight - tileHeight;        float currXPixel = getGridHorizontalStart();        for (ArrayList<Tile> currentCol : gridData.getGrid()) {            for (Tile tile : currentCol) {                RectF tileRectF = new RectF(currXPixel, currYPixel, currXPixel + tileWidth, currYPixel + tileHeight);                tile.setRectF(tileRectF);                if (tile.getImage() != null) {                    RectF imageRectF = new RectF(currXPixel, currYPixel, currXPixel + tileWidth, currYPixel + tileHeight);                    tile.getImage().setRectF(imageRectF);                }                currYPixel -= tileHeight;            }            currYPixel = getTopOfGrid() + gridHeight - tileHeight;            currXPixel += tileWidth;        }    }    private void initializeGridLines() {        int gray = Color.parseColor("#E6E6E6");        gridLinesWidth = new Paint();        gridLinesWidth.setColor(gray);        gridLinesWidth.setStrokeWidth(App.getContext().getResources().getDimensionPixelSize(R.dimen.gridLineWidth));        gridBorderPaint = new Paint();        gridBorderPaint.setColor(gray);        gridBorderPaint.setStrokeWidth(App.getContext().getResources().getDimensionPixelSize(R.dimen.gridBottomLineWidth));    }    public void drawGridLines(Canvas canvas) {        //draw grid borderlines        float gridBottom = getTopOfGrid() + gridHeight;        float gridRight = getGridHorizontalStart() + gridWidth;        canvas.drawLine(getGridHorizontalStart(), gridBottom, getGridHorizontalStart() + gridWidth, gridBottom, gridBorderPaint);        canvas.drawLine(getGridHorizontalStart(), gridBottom, getGridHorizontalStart(), getTopOfGrid(), gridBorderPaint);        canvas.drawLine(gridRight, gridBottom, gridRight, getTopOfGrid(), gridBorderPaint);        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        float tileWidth = getRectangleWidth(gridData);        float tileHeight = getRectangleHeight(gridData);        //draw horizontal lines        float currYPixel = getTopOfGrid() + tileHeight;        for (int y = 1; y < gridData.getNumOfRows(); y++) {            canvas.drawLine(getGridHorizontalStart(), currYPixel, getGridHorizontalStart() + gridWidth, currYPixel, gridLinesWidth);            currYPixel += tileHeight;        }        //draw vertical lines        float currXPixel = getGridHorizontalStart() + tileWidth;        float yStart = getTopOfGrid() + gridHeight;        float yEnd = getTopOfGrid();        for (int x = 1; x < gridData.getNumOfColumns(); x++) {            canvas.drawLine(currXPixel, yStart, currXPixel, yEnd, gridLinesWidth);            currXPixel += tileWidth;        }    }    public Animator explosionAnimation(final List<Tile> tilesToExplodeExcitingly) {        final GridData gridData = gameDataHolder.getLevelInfo().getGridData();        final float halfImageWidth = getRectangleWidth(gridData) / 2;        final float halfImageHeight = getRectangleHeight(gridData) / 2;        soundService.playSound(SoundEnum.EXPLOSION);        for (Tile tile : tilesToExplodeExcitingly) {            float horizCenter = tile.getRectF().centerX();            float vertCenter = tile.getRectF().centerY();            tile.setExplosionRectF(new RectF(horizCenter, vertCenter, horizCenter, vertCenter));        }        gameDataHolder.setShowingExplosions(true);        ValueAnimator animator = ValueAnimator.ofFloat(0, 1);        animator.setDuration(GameConstants.TILE_EXPLOSION_DURATION);        animator.setInterpolator(new AccelerateInterpolator());        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {            @Override            public void onAnimationUpdate(ValueAnimator animation) {                Float scaleFactor = (Float) animation.getAnimatedValue();                for (Tile tile : tilesToExplodeExcitingly) {                    RectF rectF = tile.getExplosionRectF();                    rectF.left = tile.getRectF().centerX() - (halfImageWidth * scaleFactor);                    rectF.right = tile.getRectF().centerX() + (halfImageWidth * scaleFactor);                    rectF.top = tile.getRectF().centerY() - (halfImageHeight * scaleFactor);                    rectF.bottom = tile.getRectF().centerY() + (halfImageHeight * scaleFactor);                }            }        });        animator.addListener(new AnimatorListenerAdapter() {            public void onAnimationEnd(Animator animation) {                gameDataHolder.setShowingExplosions(false);                for (Tile tile : tilesToExplodeExcitingly) {                    tile.setExplosionRectF(null);                }            }        });        animator.start();        return animator;    }    public Animator shrinkTouchedTiles(final GridMapping gridMapping) {        final GridData gridData = gameDataHolder.getLevelInfo().getGridData();        final float imageWidth = getRectangleWidth(gridData);        final float imageHeight = getRectangleHeight(gridData);        ValueAnimator animator = ValueAnimator.ofFloat(1, 0);        animator.setDuration(GameConstants.TILE_SHRINK_DURATION);        animator.setInterpolator(new LinearInterpolator());        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {            @Override            public void onAnimationUpdate(ValueAnimator animation) {                Float scaleFactor = (Float) animation.getAnimatedValue();                for (Tile tile : gridMapping.getTilesToRemove()) {                    if (tile.getImage() != null) {                        RectF rectF = tile.getImage().getRectF();                        float newXdistFromCtr = imageWidth / 2 * scaleFactor;                        float xCenter = rectF.centerX();                        float newYdistFromCtr = imageHeight / 2 * scaleFactor;                        float yCenter = rectF.centerY();                        rectF.set(xCenter - newXdistFromCtr, yCenter - newYdistFromCtr, xCenter + newXdistFromCtr, yCenter + newYdistFromCtr);                    }                }            }        });        animator.addListener(new AnimatorListenerAdapter() {            public void onAnimationEnd(Animator animation) {                gridService.nullifyTileImages(gridMapping.getTilesToRemove());                gridService.setImageDropDistances();                gridService.imageShift();                GameType gameType = gameDataHolder.getLevelInfo().getGameType();                if (!GameType.DROP.equals(gameType)) {                    gridService.addNewImagesToGrid(GridMappingService.this, false, gridMapping.isDueToPower());                }                dropAllBlocks(gridMapping);            }        });        animator.start();        return animator;    }    public void dropAllBlocks(GridMapping gridMapping) {        numOfBlockDropsCompleted = 0;        numOfBlocksToDrop = 0;        boolean hasBlocksToDrop = false;        final LevelInfo levelInfo = gameDataHolder.getLevelInfo();        for (ArrayList<Tile> currentCol : levelInfo.getGridData().getGrid()) {            for (Tile tile : currentCol) {                Image tileImage = tile.getImage();                if (tileImage != null && tileImage.getPlacesToDrop() != 0) {                    numOfBlocksToDrop++;                    hasBlocksToDrop = true;                    imageDropAnimation(gridMapping, tile.getImage());                }            }        }        if (!hasBlocksToDrop) {            afterAllBlocksDropped(gridMapping);        }    }    private Animator imageDropAnimation(final GridMapping gridMapping, final Image image) {        final GridData gridData = gameDataHolder.getLevelInfo().getGridData();        Integer placesToDrop = image.getPlacesToDrop();        Long timeBetweenEachImageMove = 100L;   //change this to change speed of drop        Long accelerationTime = timeBetweenEachImageMove * placesToDrop;        float distanceForOneBlock = getRectangleHeight(gridData);        Float finalDistanceToDrop = (distanceForOneBlock * placesToDrop);        if (image.isNewImage()) {            finalDistanceToDrop += getTopOfGrid();            image.setNewImage(false);        }        ValueAnimator animator = ValueAnimator.ofFloat(0, finalDistanceToDrop);        animator.setDuration(accelerationTime);        animator.setInterpolator(new AccelerateInterpolator());        ValueAnimator.setFrameDelay(24);        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {            private float originalRectFtop = image.getRectF().top;            private float originalRectFbottom = image.getRectF().bottom;            @Override            public void onAnimationUpdate(ValueAnimator animation) {                Float addedShift = (Float) animation.getAnimatedValue();                RectF rectF = image.getRectF();                rectF.set(rectF.left, originalRectFtop + addedShift, rectF.right, originalRectFbottom + addedShift);            }        });        animator.addListener(new AnimatorListenerAdapter() {            public synchronized void onAnimationEnd(Animator animation) {                numOfBlockDropsCompleted++;                if (numOfBlockDropsCompleted >= numOfBlocksToDrop) {                    afterAllBlocksDropped(gridMapping);                }            }        });        animator.start();        return animator;    }    private void afterAllBlocksDropped(GridMapping gridMapping) {        gridService.clearDropDistances();        ScoreType scoreType = gameDataHolder.getLevelInfo().getScoreType();        if (ScoreType.CHARACTER_FACES.equals(scoreType)) {            if (dropAnyCharactersAtBottomOfGrid(gridMapping)) {                return;  //return since starts at shrinking animation again and comes through            }        }        GameType gameType = gameDataHolder.getLevelInfo().getGameType();        if (gameType != GameType.TIMED) {            levelEndService.evaluateEndGame();        }        if (GameStateHolder.getGameState().equals(GameState.GRID_LOCKED)) {            GameStateHolder.setGameState(GameState.RUNNING);        }        if (gridMapping.isTouchTask()) {            TouchStateHolder.setTouchState(GridData.TouchState.ENABLED);        }        Log.d("GridMappingService", "touch enabled");    }    /**     * drops and characters at bottom of grid     *     * @return if need to drop characters     */    private boolean dropAnyCharactersAtBottomOfGrid(GridMapping gridMapping) {        List<Tile> bottomRowTilesWithCharFaces = gridService.getTilesWithCharactersOnBottomGridRow();        if (bottomRowTilesWithCharFaces.size() > 0) {            statsService.updateCharacterFacesCount(bottomRowTilesWithCharFaces.size());            gridMapping.setTilesToRemove(bottomRowTilesWithCharFaces);            shrinkTouchedTiles(gridMapping);            return true;        }        return false;    }    public void showFloatingPoints() {        final LevelInfo levelInfo = gameDataHolder.getLevelInfo();        if (levelInfo.getScoreType().equals(ScoreType.POINTS)) {            final List<Tile> touchedTiles = levelInfo.getGridData().getTouchedTiles();            Tile centerTile = touchedTiles.get((int) Math.ceil(touchedTiles.size() / 2));            final float startXPixel = centerTile.getImage().getRectF().left +                    (centerTile.getImage().getRectF().right - centerTile.getImage().getRectF().left) * 0.20f;            final float startYPixel = centerTile.getImage().getRectF().centerY();            Long scoreToAdd = statsService.getScoreToAdd(touchedTiles);            final FloatingPointsDisplay floatingPointsDisplay = new FloatingPointsDisplay(scoreToAdd, startXPixel, startYPixel);            levelInfo.getStats().setFloatingPointsDisplay(floatingPointsDisplay);            float tileHeight = getRectangleHeight(levelInfo.getGridData());            ValueAnimator animator = ValueAnimator.ofFloat(0, tileHeight / 4);            animator.setDuration(1000);            animator.setInterpolator(new LinearInterpolator());            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {                @Override                public void onAnimationUpdate(ValueAnimator animation) {                    Float scaleFactor = (Float) animation.getAnimatedValue();                    floatingPointsDisplay.setyPixelLoc(startYPixel - scaleFactor);                }            });            animator.addListener(new AnimatorListenerAdapter() {                public void onAnimationEnd(Animator animation) {                    levelInfo.getStats().setFloatingPointsDisplay(null);                }            });            animator.start();        }    }    public void blinkAnimation(final List<Tile> touchedTiles) {        final Handler blinkHandler = new Handler();        Runnable blinkRunnable = new Runnable() {            int count = 0;            boolean setTouched = false;            @Override            public void run() {                gridService.setTouchedAttrForTiles(touchedTiles, setTouched);                if (count < 2) {                    setTouched = !setTouched;                    count++;                    blinkHandler.postDelayed(this, 200);                } else {                    TouchStateHolder.setTouchState(GridData.TouchState.ENABLED);                }            }        };        blinkHandler.postDelayed(blinkRunnable, 300);    }    public Float getRectangleWidth(GridData gridData) {        return gridWidth / (float) gridData.getNumOfColumns();    }    public Float getRectangleHeight(GridData gridData) {        return gridHeight / (float) gridData.getNumOfRows();    }    public Float getTopOfGrid() {        return App.getDisplayHeight() * 0.07f;    }    public Float getGridWidht() {        return gridWidth;    }    public Float getGridHeight() {        return gridHeight;    }    private Float getGridHorizontalStart() {        return (App.getDisplayWidth() - gridWidth) / 2;    }    public void setNewImageRectangleForInitialDrop(Tile currTile, int newImagesCount, Image newImage) {        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        Float imageWidth = getRectangleWidth(gridData);        Float imageHeight = getRectangleHeight(gridData);        float left = getGridHorizontalStart() + currTile.getColNum() * imageWidth;        float right = left + imageWidth;        float bottom = 0 - (imageHeight * newImagesCount);        float top = bottom - imageHeight;        newImage.setRectF(new RectF(left, top, right, bottom));    }}