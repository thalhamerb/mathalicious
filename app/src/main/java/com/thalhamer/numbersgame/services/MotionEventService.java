package com.thalhamer.numbersgame.services;import android.os.Handler;import android.util.Log;import android.view.MotionEvent;import com.google.common.collect.Sets;import com.thalhamer.numbersgame.Exception.HandlerException;import com.thalhamer.numbersgame.domain.GameDataHolder;import com.thalhamer.numbersgame.domain.GridData;import com.thalhamer.numbersgame.domain.GridMapping;import com.thalhamer.numbersgame.domain.Image;import com.thalhamer.numbersgame.domain.LevelInfo;import com.thalhamer.numbersgame.domain.Tile;import com.thalhamer.numbersgame.enums.CalcType;import com.thalhamer.numbersgame.enums.GameState;import com.thalhamer.numbersgame.enums.MessageLocation;import com.thalhamer.numbersgame.enums.MessageType;import com.thalhamer.numbersgame.enums.NumTile;import com.thalhamer.numbersgame.enums.sounds.SoundEnum;import com.thalhamer.numbersgame.viewhelper.GameConstants;import com.thalhamer.numbersgame.viewhelper.GameStateHolder;import com.thalhamer.numbersgame.viewhelper.TouchStateHolder;import java.util.ArrayList;import java.util.List;import java.util.Set;import javax.inject.Inject;import javax.inject.Singleton;/** * Motion event service * <p/> * Created by Brian on 1/19/2015. */@Singletonpublic class MotionEventService {    @Inject    GridMappingService gridMappingService;    @Inject    StatsService statsService;    @Inject    GameDataHolder gameDataHolder;    @Inject    PowerService powerService;    @Inject    GridService gridService;    @Inject    InAppPurchaseService inAppPurchaseService;    @Inject    MessageService messageService;    @Inject    SoundService soundService;    @Inject    SpecialTileService specialTileService;    @Inject    public MotionEventService() {    }    private int numOfRetries = 0;    private Runnable processValidInputRunnable = new Runnable() {        @Override        public void run() {            processValidSequenceInput();        }    };    private Handler handler = new Handler();    public boolean handleEvent(MotionEvent event) {        if (event.getAction() == MotionEvent.ACTION_DOWN) {            actionDownEvent(event);        } else if (event.getAction() == MotionEvent.ACTION_MOVE) {            actionMoveEvent(event);        } else if (event.getAction() == MotionEvent.ACTION_UP) {            actionUpEvent(event);        }        return true;    }    private void actionDownEvent(MotionEvent event) {        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        ArrayList<ArrayList<Tile>> grid = gridData.getGrid();        gridData.setTouchedTiles(null);        gridData.setCurrentTouchedTile(null);        outerloop:        for (ArrayList<Tile> currGridCol : grid) {            for (Tile currTile : currGridCol) {                Image currImage = currTile.getImage();                if (currImage != null && currImage.getCharacter() == null                        && currImage.getRectF().contains(event.getX(), event.getY())) {                    gridData.setTouchedTiles(new ArrayList<Tile>());                    gridData.getTouchedTiles().add(currTile);                    gridData.setCurrentTouchedTile(currTile);                    currTile.setTouched(true);                    soundService.playTileCountBeep(gridData.getTouchedTiles());                    break outerloop;                }            }        }    }    private void actionMoveEvent(MotionEvent event) {        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        if (gridData.getCurrentTouchedTile() != null) {            int colNum = gridData.getCurrentTouchedTile().getColNum();            int rowNum = gridData.getCurrentTouchedTile().getRowNum();            if (gridData.getTouchedTiles() != null) {                if (removeAdjTileFromTouchedTilesIfValid(event)) {                    return;                } else if (gridData.getTouchedTiles().get(0).getImage().getPowerEnum() != null                        && gridData.getTouchedTiles().size() >= 2) {                    return;                } else if (addAdjTileToTouchedTilesIfValid(event, colNum + 1, rowNum)) {                    return;                } else if (addAdjTileToTouchedTilesIfValid(event, colNum, rowNum + 1)) {                    return;                } else if (addAdjTileToTouchedTilesIfValid(event, colNum - 1, rowNum)) {                    return;                } else if (addAdjTileToTouchedTilesIfValid(event, colNum, rowNum - 1)) {                    return;                }            }        }    }    private boolean removeAdjTileFromTouchedTilesIfValid(MotionEvent event) {        //if person moves back, it deletes previous tile        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        List<Tile> touchedTiles = gridData.getTouchedTiles();        if (touchedTiles.size() > 1 && imageContainsMotionEvent(event, touchedTiles.get(touchedTiles.size() - 2).getImage())) {            Tile previousTile = touchedTiles.get(touchedTiles.size() - 2);            Tile currTouchedTile = gridData.getCurrentTouchedTile();            touchedTiles.remove(currTouchedTile);            currTouchedTile.setTouched(false);            gridData.setCurrentTouchedTile(previousTile);            soundService.playTileCountBeep(touchedTiles);            return true;        }        return false;    }    private boolean addAdjTileToTouchedTilesIfValid(MotionEvent event, int colNum, int rowNum) {        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        if (colNum < gridData.getNumOfColumns() && colNum >= 0 && rowNum < gridData.getNumOfRows() && rowNum >= 0) {            Tile adjTile = gridData.getGrid().get(colNum).get(rowNum);            if (!gridData.getTouchedTiles().contains(adjTile) && tileImageValidOnMoveEvent(adjTile)) {                if (imageContainsMotionEvent(event, adjTile.getImage()) && checkPowerEnumSequence(gridData.getTouchedTiles(), adjTile)) {                    gridData.getTouchedTiles().add(adjTile);                    gridData.setCurrentTouchedTile(adjTile);                    adjTile.setTouched(true);                    soundService.playTileCountBeep(gridData.getTouchedTiles());                    return true;                }            }        }        return false;    }    private boolean checkPowerEnumSequence(List<Tile> tiles, Tile adjTile) {        return tiles.get(0).getImage().getPowerEnum() == null || adjTile.getImage().getNumTile() != null;    }    private boolean tileImageValidOnMoveEvent(Tile tile) {        return tile.getImage() != null && tile.getImage().getCharacter() == null && tile.getImage().getPowerEnum() == null;    }    private boolean imageContainsMotionEvent(MotionEvent event, Image image) {        return image != null && image.getRectF().contains(event.getX(), event.getY());    }    private synchronized void actionUpEvent(MotionEvent event) {        LevelInfo levelInfo = gameDataHolder.getLevelInfo();        List<Tile> touchedTiles = levelInfo.getGridData().getTouchedTiles();        if (touchedTiles != null) {            if (touchedTiles.get(0).getImage().getPowerEnum() != null && touchedTiles.size() == 2) {                processValidPowerEnumInput();            } else if (touchedTiles.size() == 1) {                checkPowers(touchedTiles.get(0));                for (Tile tile : touchedTiles) {                    tile.setTouched(false);                }            } else if (checkTilesCalculateToCorrectValue(levelInfo)) {                TouchStateHolder.setTouchState(GridData.TouchState.DISABLED);                processValidSequenceInput();            } else {                TouchStateHolder.setTouchState(GridData.TouchState.DISABLED);                gridMappingService.blinkAnimation(touchedTiles);                showNegativeCharacterMessage(levelInfo);                soundService.playSound(SoundEnum.NEGATIVE_BEEP);            }        }        //handle power touch event        powerService.resetAndCheckActive(event, inAppPurchaseService);    }    private void checkPowers(Tile touchedTile) {        try {            powerService.performPowerIfAnyActive(touchedTile, gridMappingService);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    private void processValidSequenceInput() {        try {            gameDataHolder.getGridLock().lock();            if (GameStateHolder.getGameState() != GameState.GRID_LOCKED) {                Log.d("MotionEventService", "touch disabled");                numOfRetries = 0;                GameStateHolder.setGameState(GameState.GRID_LOCKED);                runValidInputTasks();            } else {                if (numOfRetries < 40) {                    handler.postDelayed(processValidInputRunnable, 100);                    numOfRetries++;                } else {                    throw new HandlerException("MotionEventService: Runaway exception!!! :(");                }            }            gameDataHolder.getGridLock().unlock();        } catch (InterruptedException | HandlerException e) {            List<Tile> touchedTiles = gameDataHolder.getLevelInfo().getGridData().getTouchedTiles();            gridService.setTouchedAttrForTiles(touchedTiles, false);            numOfRetries = 0;            e.printStackTrace();        }    }    private void processValidPowerEnumInput() {        List<Tile> touchedTiles = gameDataHolder.getLevelInfo().getGridData().getTouchedTiles();        gridService.setTouchedAttrForTiles(touchedTiles, false);        Set<Tile> tilesToShrink = Sets.newHashSet(touchedTiles);        tilesToShrink.addAll(gridService.getAllTilesWithNum(touchedTiles.get(1)));        List<Tile> tilesToShrinkAsList = new ArrayList<>(tilesToShrink);        powerService.performBlockDeletion(touchedTiles.get(1), tilesToShrinkAsList, gridMappingService);    }    private void runValidInputTasks() {        Log.d("MotionEventService", "processValidInput");        List<Tile> touchedTiles = gameDataHolder.getLevelInfo().getGridData().getTouchedTiles();        gridService.setTouchedAttrForTiles(touchedTiles, false);        statsService.updateStats(touchedTiles);        showPositiveCharacterMessage(touchedTiles);        specialTileService.processSpecialTile(touchedTiles);        gridService.reduceTileAttribute(touchedTiles);        gridService.reduceAdjBlocks(touchedTiles);        gridMappingService.showFloatingPoints();        //start image drop process        final GridMapping gridMapping = gridService.createGridMapping(true);        gridMapping.setDueToPower(false);        gridMapping.setTilesToRemove(touchedTiles);        gridMappingService.shrinkTouchedTiles(gridMapping);    }    private void showPositiveCharacterMessage(List<Tile> touchedTiles) {        //if it's not already opened        if (!gameDataHolder.isShowThoughtBubble()) {            if (touchedTiles.size() >= GameConstants.CHARACTER_MESSAGE_LARGE_SEQUENCE) {                //pos game phrases                String message = messageService.getRandomGameMessage(null, MessageType.POSITIVE, MessageLocation.DURING_GAME);                setMessage(message);                soundService.playSound(SoundEnum.POSITIVE_BEEP_02);            } else if (touchedTiles.size() >= GameConstants.CHARACTER_MESSAGE_MEDIUM_SEQUENCE) {                //normal game phrases                String message = messageService.getRandomGameMessage(null, MessageType.NORMAL, MessageLocation.DURING_GAME);                setMessage(message);                soundService.playSound(SoundEnum.POSITIVE_BEEP_01);            }        }    }    private void showNegativeCharacterMessage(LevelInfo levelInfo) {        if (!gameDataHolder.isShowThoughtBubble()) {            String message = String.format("That equals %d.", getTilesTotal(levelInfo));            setMessage(message);        }    }    private void setMessage(String message) {        gameDataHolder.getThoughtBubbleString().clear();        gameDataHolder.getThoughtBubbleString().append(message);        gameDataHolder.setShowThoughtBubble(true);        initThoughtBubbleCloseTimer(3000);    }    private void initThoughtBubbleCloseTimer(long timeToClose) {        Runnable runnable = new Runnable() {            @Override            public void run() {                gameDataHolder.setShowThoughtBubble(false);            }        };        new Handler().postDelayed(runnable, timeToClose);    }    private int getTilesTotal(LevelInfo levelInfo) {        int total = 0;        if (CalcType.ADD.equals(levelInfo.getCalcType())) {            for (Tile tile : levelInfo.getGridData().getTouchedTiles()) {                NumTile numTile = tile.getImage().getNumTile();                if (numTile != null) {                    total += numTile.getValue();                }            }        } else if (CalcType.SUBTRACT.equals(levelInfo.getCalcType())) {            List<Tile> touchedTiles = levelInfo.getGridData().getTouchedTiles();            Integer firstNumTileLocation = getLocationOfFirstNumTile(touchedTiles);            total = touchedTiles.get(firstNumTileLocation).getImage().getNumTile().getValue();            for (int i = firstNumTileLocation + 1; i < touchedTiles.size(); i++) {                NumTile numTile = touchedTiles.get(i).getImage().getNumTile();                if (numTile != null) {                    total -= numTile.getValue();                }            }        } else if (CalcType.MULTIPLY.equals(levelInfo.getCalcType())) {            total = 1;            for (Tile tile : levelInfo.getGridData().getTouchedTiles()) {                NumTile numTile = tile.getImage().getNumTile();                if (numTile != null) {                    total *= numTile.getValue();                }            }        }        return total;    }    private Integer getLocationOfFirstNumTile(List<Tile> tiles) {        for (int i = 0; i < tiles.size(); i++) {            if (tiles.get(i).getImage().getNumTile() != null) {                return i;            }        }        return null;    }    private boolean checkTilesCalculateToCorrectValue(LevelInfo levelInfo) {        return getTilesTotal(levelInfo) == levelInfo.getGridData().getNumToAddUpTo();    }}