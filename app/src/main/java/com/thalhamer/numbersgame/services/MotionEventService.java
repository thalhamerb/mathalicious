package com.thalhamer.numbersgame.services;import android.os.Handler;import android.util.Log;import android.view.MotionEvent;import com.google.common.collect.Sets;import com.thalhamer.numbersgame.Exception.HandlerException;import com.thalhamer.numbersgame.domain.GameDataHolder;import com.thalhamer.numbersgame.domain.GridData;import com.thalhamer.numbersgame.domain.GridMapping;import com.thalhamer.numbersgame.domain.Image;import com.thalhamer.numbersgame.domain.LevelInfo;import com.thalhamer.numbersgame.domain.Tile;import com.thalhamer.numbersgame.enums.GameState;import com.thalhamer.numbersgame.enums.MessageLocation;import com.thalhamer.numbersgame.enums.MessageType;import com.thalhamer.numbersgame.enums.sounds.SoundEnum;import com.thalhamer.numbersgame.viewhelper.GameConstants;import com.thalhamer.numbersgame.viewhelper.GameStateHolder;import com.thalhamer.numbersgame.viewhelper.TouchStateHolder;import java.util.ArrayList;import java.util.List;import java.util.Set;import javax.inject.Inject;import javax.inject.Singleton;/** * Motion event service * <p/> * Created by Brian on 1/19/2015. */@Singletonpublic class MotionEventService {    @Inject    GridMappingService gridMappingService;    @Inject    StatsService statsService;    @Inject    GameDataHolder gameDataHolder;    @Inject    PowerService powerService;    @Inject    GridService gridService;    @Inject    InAppPurchaseService inAppPurchaseService;    @Inject    MessageService messageService;    @Inject    SoundService soundService;    @Inject    SpecialTileService specialTileService;    @Inject    TimerService timerService;    @Inject    GridTileDataService gridTileDataService;    @Inject    UserAdviceService userAdviceService;    @Inject    public MotionEventService() {    }    private int numOfRetries = 0;    private Runnable processValidInputRunnable = new Runnable() {        @Override        public void run() {            processValidSequenceInput();        }    };    private Handler handler = new Handler();    public boolean handleEvent(MotionEvent event) {        if (event.getAction() == MotionEvent.ACTION_DOWN) {            actionDownEvent(event);        } else if (event.getAction() == MotionEvent.ACTION_MOVE) {            actionMoveEvent(event);        } else if (event.getAction() == MotionEvent.ACTION_UP) {            actionUpEvent(event);        }        return true;    }    private void actionDownEvent(MotionEvent event) {        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        ArrayList<ArrayList<Tile>> grid = gridData.getGrid();        gridData.setTouchedTiles(null);        gridData.setCurrentTouchedTile(null);        outerloop:        for (ArrayList<Tile> currGridCol : grid) {            for (Tile currTile : currGridCol) {                Image currImage = currTile.getImage();                if (currImage != null && currImage.getCharacter() == null                        && currImage.getRectF().contains(event.getX(), event.getY())) {                    gridData.setTouchedTiles(new ArrayList<Tile>());                    gridData.getTouchedTiles().add(currTile);                    gridData.setCurrentTouchedTile(currTile);                    currTile.setTouched(true);                    soundService.playTileCountBeep(gridData.getTouchedTiles());                    break outerloop;                }            }        }    }    private void actionMoveEvent(MotionEvent event) {        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        if (gridData.getCurrentTouchedTile() != null) {            int colNum = gridData.getCurrentTouchedTile().getColNum();            int rowNum = gridData.getCurrentTouchedTile().getRowNum();            if (gridData.getTouchedTiles() != null) {                if (removeAdjTileFromTouchedTilesIfValid(event)) {                    return;                } else if (gridData.getTouchedTiles().get(0).getImage().getPowerEnum() != null                        && gridData.getTouchedTiles().size() >= 2) {                    return;                } else if (addAdjTileToTouchedTilesIfValid(event, colNum + 1, rowNum)) {                    return;                } else if (addAdjTileToTouchedTilesIfValid(event, colNum, rowNum + 1)) {                    return;                } else if (addAdjTileToTouchedTilesIfValid(event, colNum - 1, rowNum)) {                    return;                } else if (addAdjTileToTouchedTilesIfValid(event, colNum, rowNum - 1)) {                    return;                }            }        }    }    private boolean removeAdjTileFromTouchedTilesIfValid(MotionEvent event) {        //if person moves back, it deletes previous tile        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        List<Tile> touchedTiles = gridData.getTouchedTiles();        if (touchedTiles.size() > 1 && imageContainsMotionEvent(event, touchedTiles.get(touchedTiles.size() - 2).getImage())) {            Tile previousTile = touchedTiles.get(touchedTiles.size() - 2);            Tile currTouchedTile = gridData.getCurrentTouchedTile();            touchedTiles.remove(currTouchedTile);            currTouchedTile.setTouched(false);            gridData.setCurrentTouchedTile(previousTile);            soundService.playTileCountBeep(touchedTiles);            return true;        }        return false;    }    private boolean addAdjTileToTouchedTilesIfValid(MotionEvent event, int colNum, int rowNum) {        GridData gridData = gameDataHolder.getLevelInfo().getGridData();        if (colNum < gridData.getNumOfColumns() && colNum >= 0 && rowNum < gridData.getNumOfRows() && rowNum >= 0) {            Tile adjTile = gridData.getGrid().get(colNum).get(rowNum);            if (!gridData.getTouchedTiles().contains(adjTile) && tileImageValidOnMoveEvent(adjTile)) {                if (imageContainsMotionEvent(event, adjTile.getImage()) && checkPowerEnumSequence(gridData.getTouchedTiles(), adjTile)) {                    gridData.getTouchedTiles().add(adjTile);                    gridData.setCurrentTouchedTile(adjTile);                    adjTile.setTouched(true);                    soundService.playTileCountBeep(gridData.getTouchedTiles());                    return true;                }            }        }        return false;    }    private boolean checkPowerEnumSequence(List<Tile> tiles, Tile adjTile) {        return tiles.get(0).getImage().getPowerEnum() == null || adjTile.getImage().getNumTile() != null;    }    private boolean tileImageValidOnMoveEvent(Tile tile) {        return tile.getImage() != null && tile.getImage().getCharacter() == null && tile.getImage().getPowerEnum() == null;    }    private boolean imageContainsMotionEvent(MotionEvent event, Image image) {        return image != null && image.getRectF().contains(event.getX(), event.getY());    }    private synchronized void actionUpEvent(MotionEvent event) {        LevelInfo levelInfo = gameDataHolder.getLevelInfo();        List<Tile> touchedTiles = levelInfo.getGridData().getTouchedTiles();        if (touchedTiles != null) {            if (touchedTiles.get(0).getImage().getPowerEnum() != null && touchedTiles.size() == 2) {                processValidPowerEnumInput();            } else if (touchedTiles.size() == 1) {                powerService.performPowerIfAnyActive(touchedTiles.get(0), gridMappingService);                for (Tile tile : touchedTiles) {                    tile.setTouched(false);                }            } else if (checkTilesCalculateToCorrectValue(levelInfo)) {                TouchStateHolder.setTouchState(GridData.TouchState.DISABLED);                processValidSequenceInput();            } else {                TouchStateHolder.setTouchState(GridData.TouchState.DISABLED);                gridMappingService.blinkAnimation(touchedTiles);                int tilesTotal = gridService.getTilesTotal(levelInfo);                messageService.showWrongTotalCharacterMessage(tilesTotal);                soundService.playSound(SoundEnum.NEGATIVE_BEEP);            }        } else if (gameDataHolder.getInfoRectF().contains(event.getX(), event.getY())) {            gridTileDataService.initLevelExplanation(gameDataHolder.getLevelActivity(), timerService);            timerService.stopTimersAndHandlerCallbacks();        } else {            powerService.handlePowerClickEvent(event, inAppPurchaseService, timerService);        }    }    private void processValidSequenceInput() {        try {            gameDataHolder.getGridLock().lock();            if (GameStateHolder.getGameState() != GameState.GRID_LOCKED) {                Log.d("MotionEventService", "touch disabled");                numOfRetries = 0;                GameStateHolder.setGameState(GameState.GRID_LOCKED);                runValidInputTasks();            } else {                if (numOfRetries < 40) {                    handler.postDelayed(processValidInputRunnable, 100);                    numOfRetries++;                } else {                    throw new HandlerException("MotionEventService: Runaway exception!!! :(");                }            }            gameDataHolder.getGridLock().unlock();        } catch (InterruptedException | HandlerException e) {            List<Tile> touchedTiles = gameDataHolder.getLevelInfo().getGridData().getTouchedTiles();            gridService.setTouchedAttrForTiles(touchedTiles, false);            numOfRetries = 0;            e.printStackTrace();        }    }    private void processValidPowerEnumInput() {        userAdviceService.resetNumOfMovesWithoutUsingPowerTile();        List<Tile> touchedTiles = gameDataHolder.getLevelInfo().getGridData().getTouchedTiles();        gridService.setTouchedAttrForTiles(touchedTiles, false);        Set<Tile> tilesToShrink = Sets.newHashSet(touchedTiles);        tilesToShrink.addAll(gridService.getAllTilesWithNum(touchedTiles.get(1)));        List<Tile> tilesToShrinkAsList = new ArrayList<>(tilesToShrink);        powerService.performBlockDeletion(touchedTiles.get(1), tilesToShrinkAsList, gridMappingService);    }    private void runValidInputTasks() {        Log.d("MotionEventService", "processValidInput");        List<Tile> touchedTiles = gameDataHolder.getLevelInfo().getGridData().getTouchedTiles();        gridService.setTouchedAttrForTiles(touchedTiles, false);        statsService.updateStats(touchedTiles);        initPositiveFeedback(touchedTiles);        specialTileService.processSpecialTile(touchedTiles);        gridService.reduceTileAttribute(touchedTiles);        gridService.reduceAdjBlocks(touchedTiles);        gridMappingService.showFloatingPoints();        userAdviceService.giveAdvice(touchedTiles);        //start image drop process        final GridMapping gridMapping = gridService.createGridMapping(true);        gridMapping.setDueToPower(false);        gridMapping.setTilesToRemove(touchedTiles);        gridMappingService.shrinkTouchedTiles(gridMapping);    }    private void initPositiveFeedback(List<Tile> touchedTiles) {        //if it's not already opened        if (!gameDataHolder.isShowThoughtBubble()) {            if (touchedTiles.size() >= GameConstants.CHARACTER_MESSAGE_LARGE_SEQUENCE) {                //pos game phrases                String message = messageService.getRandomGameMessage(null, MessageType.POSITIVE, MessageLocation.DURING_GAME);                messageService.initCharacterMessage(message);                soundService.playSound(SoundEnum.POSITIVE_BEEP_02);            } else if (touchedTiles.size() >= GameConstants.CHARACTER_MESSAGE_MEDIUM_SEQUENCE) {                //normal game phrases                String message = messageService.getRandomGameMessage(null, MessageType.NORMAL, MessageLocation.DURING_GAME);                messageService.initCharacterMessage(message);                soundService.playSound(SoundEnum.POSITIVE_BEEP_01);            }        }    }    private boolean checkTilesCalculateToCorrectValue(LevelInfo levelInfo) {        return gridService.getTilesTotal(levelInfo) == levelInfo.getGridData().getNumToAddUpTo();    }}