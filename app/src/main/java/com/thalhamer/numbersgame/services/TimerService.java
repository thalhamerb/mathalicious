package com.thalhamer.numbersgame.services;import android.os.AsyncTask;import android.os.CountDownTimer;import android.os.Handler;import android.util.Log;import com.thalhamer.numbersgame.domain.DropBlockData;import com.thalhamer.numbersgame.domain.GameDataHolder;import com.thalhamer.numbersgame.domain.GridMapping;import com.thalhamer.numbersgame.domain.LevelInfo;import com.thalhamer.numbersgame.domain.Stats;import com.thalhamer.numbersgame.domain.Tile;import com.thalhamer.numbersgame.enums.GameType;import com.thalhamer.numbersgame.enums.ScoreType;import com.thalhamer.numbersgame.enums.sounds.SoundEnum;import java.util.List;import javax.inject.Inject;import javax.inject.Singleton;/** * Timer Service * <p/> * Created by Brian on 4/24/2015. */@Singletonpublic class TimerService {    @Inject    GameDataHolder gameDataHolder;    @Inject    GameEndService gameEndService;    @Inject    GridService gridService;    @Inject    GridMappingService gridMappingService;    @Inject    SoundService soundService;    private CountDownTimer countDownTimer;    private int initialPeriod;    private Handler freqHandler;    private boolean gameCurrentlyRunning = false;    /**     * can be used for start or restart of timers and callbacks     */    public void startTimersAndHandlerCallbacks() {        if (!gameCurrentlyRunning) {            gameCurrentlyRunning = true;            LevelInfo levelInfo = gameDataHolder.getLevelInfo();            gameDataHolder.setBlockDropHandler(new Handler());            if (levelInfo.getGameType().equals(GameType.TIMED)) {                startCountDownTimer();            } else if (GameType.DROP.equals(levelInfo.getGameType())) {                DropBlockData dropBlockData = levelInfo.getDropBlockData();                startBlockDropTimer(dropBlockData);            }            if (gameDataHolder.getLevelInfo().getScoreType().equals(ScoreType.TIME)) {                gameDataHolder.setCountUpHandler(new Handler());                startCountUpTimer();            }        }    }    public void stopTimersAndHandlerCallbacks() {        if (gameCurrentlyRunning) {            gameCurrentlyRunning = false;            if (countDownTimer != null) {                countDownTimer.cancel();            }            if (gameDataHolder.getBlockDropHandler() != null) {                gameDataHolder.getBlockDropHandler().removeCallbacksAndMessages(null);            }            if (freqHandler != null) {                freqHandler.removeCallbacksAndMessages(null);            }            if (gameDataHolder.getCountUpHandler() != null) {                gameDataHolder.getCountUpHandler().removeCallbacksAndMessages(null);            }            if (gameDataHolder.getCountUpHandler() != null) {                gameDataHolder.getCountUpHandler().removeCallbacksAndMessages(null);            }        }    }    private CountDownTimer startCountDownTimer() {        final LevelInfo levelInfo = gameDataHolder.getLevelInfo();        countDownTimer = new CountDownTimer(levelInfo.getStats().getNumOfMillisLeft(), 500) {            public void onTick(long millisUntilFinished) {                levelInfo.getStats().setNumOfMillisLeft(millisUntilFinished);                if (millisUntilFinished % 1000 <= 10) {                    soundService.playSound(SoundEnum.COUNTDOWN_BEEP);                }            }            public void onFinish() {                gameEndService.startEndGameProcess();            }        };        return countDownTimer.start();    }    private void startCountUpTimer() {        final Stats stats = gameDataHolder.getLevelInfo().getStats();        Runnable runnable = new Runnable() {            @Override            public void run() {                stats.setTimeElapsed(stats.getTimeElapsed() + 1000);                gameDataHolder.getCountUpHandler().postDelayed(this, 1000);            }        };        gameDataHolder.getCountUpHandler().postDelayed(runnable, 1000);        gameDataHolder.setCountUpHandler(gameDataHolder.getCountUpHandler());    }    private void startBlockDropTimer(DropBlockData dropBlockData) {        //initial variable sets        final int periodBetweenFreqChanges = dropBlockData.getPeriodBetweenFreqChanges();        final double periodChangeFactor = dropBlockData.getPeriodChangeFactor();        this.initialPeriod = dropBlockData.getInitialPeriod();        startBlockDropFrequencyUpdater(periodBetweenFreqChanges, periodChangeFactor);        startPeriodicBlockDrop();    }    private void startPeriodicBlockDrop() {        Runnable blockDropRunnable = new Runnable() {            @Override            public void run() {                AsyncTask.execute(new Runnable() {                    @Override                    public void run() {                        try {                            gameDataHolder.getGridLock().lock();                            performBlockDropTasks();                            gameDataHolder.getBlockDropHandler().postDelayed(this, TimerService.this.initialPeriod);                        } catch (InterruptedException e) {                            List<Tile> touchedTiles = gameDataHolder.getLevelInfo().getGridData().getTouchedTiles();                            gridService.setTouchedAttrForTiles(touchedTiles, false);                            e.printStackTrace();                        }                    }                });            }        };        gameDataHolder.getBlockDropHandler().postDelayed(blockDropRunnable, this.initialPeriod);    }    private void performBlockDropTasks() {        final GridMapping gridMapping = gridService.createGridMapping(true);        gameDataHolder.getGameActivity().runOnUiThread(new Runnable() {            @Override            public void run() {                if (!gridService.topRowHasImage()) {                    Log.d("TimerService", "periodic block drop started");                    gridService.addNewImagesToGrid(gridMappingService, true, false);                    gridMappingService.dropAllBlocks(gridMapping);                }            }        });    }    private void startBlockDropFrequencyUpdater(final int periodBetweenFreqChanges, final double periodChangeFactor) {        Runnable freqRunnable = new Runnable() {            @Override            public void run() {                int newPeriod = (int) (TimerService.this.initialPeriod * periodChangeFactor);                TimerService.this.initialPeriod = newPeriod < 5 ? 5 : newPeriod;                freqHandler.postDelayed(this, periodBetweenFreqChanges);            }        };        freqHandler = new Handler();        freqHandler.postDelayed(freqRunnable, periodBetweenFreqChanges);    }}