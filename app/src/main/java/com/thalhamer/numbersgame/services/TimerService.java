package com.thalhamer.numbersgame.services;import android.os.CountDownTimer;import android.os.Handler;import android.util.Log;import com.thalhamer.numbersgame.Exception.HandlerException;import com.thalhamer.numbersgame.R;import com.thalhamer.numbersgame.domain.DropBlockData;import com.thalhamer.numbersgame.domain.GameDataHolder;import com.thalhamer.numbersgame.domain.GridMapping;import com.thalhamer.numbersgame.domain.LevelInfo;import com.thalhamer.numbersgame.enums.GameState;import com.thalhamer.numbersgame.enums.GameType;import com.thalhamer.numbersgame.viewhelper.GameStateHolder;import javax.inject.Inject;import javax.inject.Singleton;/** * Timer Service * <p/> * Created by Brian on 4/24/2015. */@Singletonpublic class TimerService {    @Inject    GameDataHolder gameDataHolder;    @Inject    LevelEndService levelEndService;    @Inject    GridService gridService;    @Inject    GridMappingService gridMappingService;    @Inject    SoundService soundService;    private int numOfRetries = 0;    private CountDownTimer countDownTimer;    private boolean gameCurrentlyRunning = false;    private int dropBlockPeriod;    private Long timeLeftUntilNextBlockDrop = null;    private Long timeSupposedToRun = null;    /**     * can be used for start or restart of timers and callbacks     */    public void startTimersAndHandlerCallbacks() {        if (!gameCurrentlyRunning) {            LevelInfo levelInfo = gameDataHolder.getLevelInfo();            if (levelInfo.getGameType().equals(GameType.TIMED)) {                startCountDownTimer();            } else if (GameType.DROP.equals(levelInfo.getGameType())) {                gameDataHolder.setBlockDropHandler(new Handler());                DropBlockData dropBlockData = levelInfo.getDropBlockData();                startBlockDropTimer(dropBlockData);            }            gameCurrentlyRunning = true;        }    }    public void stopTimersAndHandlerCallbacks() {        if (gameCurrentlyRunning) {            gameCurrentlyRunning = false;            if (countDownTimer != null) {                countDownTimer.cancel();            }            if (gameDataHolder.getBlockDropHandler() != null) {                if (timeSupposedToRun != null) {                    timeLeftUntilNextBlockDrop = timeSupposedToRun - System.currentTimeMillis();                }                gameDataHolder.getBlockDropHandler().removeCallbacksAndMessages(null);            }        }    }    private CountDownTimer startCountDownTimer() {        final LevelInfo levelInfo = gameDataHolder.getLevelInfo();        countDownTimer = new CountDownTimer(levelInfo.getStats().getNumOfMillisLeft(), 500) {            public void onTick(long millisUntilFinished) {                levelInfo.getStats().setNumOfMillisLeft(millisUntilFinished);                if (millisUntilFinished / 500 == 40) {                    soundService.playSound(R.raw.times_almost_up);                }            }            public void onFinish() {                levelEndService.startEndGameProcess();            }        };        return countDownTimer.start();    }    private void startBlockDropTimer(DropBlockData dropBlockData) {        this.dropBlockPeriod = dropBlockData.getInitialPeriod();        startPeriodicBlockDrop(dropBlockData);    }    private void startPeriodicBlockDrop(final DropBlockData dropBlockData) {        Runnable blockDropRunnable = new Runnable() {            @Override            public void run() {                try {                    gameDataHolder.getGridLock().lock();                    if (GameStateHolder.getGameState() != GameState.GRID_LOCKED) {                        Log.d("TimerService", "touch disabled");                        numOfRetries = 0;                        GameStateHolder.setGameState(GameState.GRID_LOCKED);                        performBlockDropTasks();                        double periodChangeFactor = dropBlockData.getPeriodChangeFactor();                        int newPeriod = (int) (dropBlockPeriod * periodChangeFactor);                        dropBlockPeriod = newPeriod < 5 ? 5 : newPeriod;                        postDelayedBlockDropMessage(this, dropBlockPeriod);                    } else {                        if (numOfRetries < 40) {                            gameDataHolder.getBlockDropHandler().postDelayed(this, 100);                            numOfRetries++;                        } else {                            throw new HandlerException("TimerService: Runaway exception!!! :(");                        }                    }                    gameDataHolder.getGridLock().unlock();                } catch (InterruptedException | HandlerException e) {                    numOfRetries = 0;                    e.printStackTrace();                }            }        };        if (timeLeftUntilNextBlockDrop != null) {            postDelayedBlockDropMessage(blockDropRunnable, timeLeftUntilNextBlockDrop);            timeLeftUntilNextBlockDrop = null;        } else {            postDelayedBlockDropMessage(blockDropRunnable, dropBlockPeriod);        }    }    private void postDelayedBlockDropMessage(Runnable blockDropRunnable, long timeDelay) {        gameDataHolder.getBlockDropHandler().postDelayed(blockDropRunnable, timeDelay);        timeSupposedToRun = System.currentTimeMillis() + timeDelay;    }    private void performBlockDropTasks() {        if (!gridService.topRowHasImage()) {            Log.d("TimerService", "periodic block drop started");            gridService.addNewImagesToGrid(gridMappingService, true, false);            final GridMapping gridMapping = gridService.createGridMapping(true);            gridMappingService.dropAllBlocks(gridMapping);        }    }}